# A library for Network Decision Diagram

This is a prototype implementation of the following [paper]():

> Zechun Li, Peng Zhang, Yichi Zhang, and Hongkun Yang. "NDD: A Decision Diagram for Network Verification", NSDI 2025

## Introduction

**Network Decision Diagram (NDD)** is a new decision diagram customized for network verification. It is more efficient than BDD when used for network verification, in terms of memory and computation. NDD wraps BDD with another layers of decision diagram, such that each node represents a **field** of the network, and each edge is labeled with a BDD encoding the values of that field. Due to the **locality** of fields in networks, NDD can significantly reduce the redundant nodes. 

**Atomized Network Decision Diagram (Atomized NDD)** is an extension of NDD, which offers a native support for equivalence classes, a key technique underlying most network verifiers.
In atomized NDD, the label of each edge is a set of atoms, instead of a BDD as in standard NDD.
Using atomized NDD, network verifiers do not need to implement their own algorithms for computing and updating equivalence classes.

**Todo: add a example of BDD, NDD, and atomized NDD.**

<!--
### Definitions

**Definition 1.** A **Network Decision Diagram (NDD)** is a rooted, directed acyclic graph with:

- two terminal nodes ***true*** and ***false***, with an out-degree of zero.

- a set of non-terminal nodes. Each node u is associated with a variable var(u) representing a field of one or multiple bits, and has a set of outgoing edges, denoted as edges(u). Each e $\in$ edges(u) points to a successor of u, denoted as next(e), and has a predicate over the variable var(u), denoted as label(e).

- $\forall u, \forall x, y \in edges(u)$ with $x \ne y$: $label(x)\wedge label(y) = false$, and $\bigvee_{e \in edges(u)}label(e) = true$.

**Todo: add a figure of redundancy in NDD.**

**Definition 2.** A NDD is said to be an **Ordered (ONDD)** if the field variables follow a fixed variable order
(say $f_1 < f_2 < ...,< f_n$ where $f_i < f_j$ means variable $f_i$ appears before variable $f_j$) on all paths through the graph. An ONDD is said to be a **Reduced (RONDD)** if it satisfies the following three conditions:
- Uniqueness: no two distinct nodes represent the same variable and have the same successors;
- No redundant node: no non-terminal node has only edge e with $label(e) = true$;
- No redundant edges: no two edges from the same node point to the same successor, i.e., $\forall u,\forall x, y \in edge(u) : next(x) = next(y) \Rightarrow x = y$.

**Definition 3.** Given a set of NDDs $N$ for a set of variables $F$, we say $A(f) = {{a_1}^f,...,{a_k}^f}$ is the set of **atoms** for variable $f \in F$, with respect with $N$ , if it satisfies the following conditions:
- $a_i^f \ne false,\forall i ∈ {1,..., k}$;
- $\vee_{i=1}^k a_i^f = true$;
- $a_i^f∧a_j^f = false$, if $i \ne j$;
- $\forall e \in edges(u)$, $u$ is a node of $N$ $var(u) = f$: there exists a set $atoms(e) \subset A(f)$, s.t., $label(e) = $\bigvee_{a \in atoms(e)}a$;
- $k$ is the minimum number satisfy the above properties.

**Definition 4.** Given a set of NDDs $N$, we say $N^a$ a is the **atomized NDDs** of $N$, if $N^a = N$ , except that for each $e$ of $N^a$: $label(e) \leftarrow atoms(e)$.
-->

## Project Structure

- `/doc` stores an api documentation generated by `javadoc`.
- `/lib` stores the third party jar packages.
    - `jdd-111.jar` is a modified version of [jdd library](https://bitbucket.org/vahidi/jdd), whose source code can be [access](https://github.com/Augists/jdd).
    - `javabdd_1.0b2.tar.gz` is the original version of [javabdd](https://sourceforge.net/projects/javabdd/) (for comparison).
- `/results` stores some experimental results generated by codes in `/src/experiment`.
- `/src` stores source code.

## Getting Started

Download the NDD package to `/lib/ndd-1.0.jar` and add `<dependency>` in `pom.xml`

```xml
<dependencies>
    <dependency>
        <groupId>org.ants</groupId>
        <artifactId>ndd</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/lib/ndd-1.0.jar</systemPath>
    </dependency>
</dependencies>
```

### jndd

An [example](/src/main/java/application/nqueen/NDDSolution.java) shows how to solve the NQueens problem by NDD.

```java
// init NDD library
NDD.initNDD(NDD_TABLE_SIZE, 1 + Math.max(1000, (int) (Math.pow(4.4, n - 6)) * 1000), 10000);

// declare ndd fields
for (int i = 0; i < n; i++) {
    NDD.declareField(n);
}

// constraints
NDD[] orBatch = new NDD[n];
NDD[][] impBatch = new NDD[n][n];

for (int i = 0; i < n; i++) {
    NDD condition = NDD.getFalse();
    for (int j = 0; j < n; j++) {
        condition = NDD.orTo(condition, NDD.getVar(i, j));
    }
    orBatch[i] = condition;
}

for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        build(i, j, n, impBatch);
	}
}

// result computation
NDD queen = NDD.getTrue();

for (int i = 0; i < n; i++) {
    queen = NDD.andTo(queen, orBatch[i]);
    NDD.deref(orBatch[i]);
}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        queen = NDD.andTo(queen, impBatch[i][j]);
        NDD.deref(impBatch[i][j]);
    }
}

return NDD.satCount(queen);
```

### JavaNDD

Library and its usage can be accessed in [src/main/java/org/ants/javandd](src/main/java/org/ants/javandd/README.md)

**TODO More details on how to use javandd?**

## Benchmark

**TODO: show a table for benchmark results, and compare to Ryan's Decision Diagram if possible.**

### Contact

- Zechun Li (1467874668@qq.com)
- Peng Zhang (p-zhang@xjtu.edu.cn)
- Yichi Zhang (augists@outlook.com)
- Hongkun Yang (hkyang@google.com)

## License

Apache-2.0 License, see [LICENSE](LICENSE).
