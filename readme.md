# A library for Network Decision Diagram

This project provides a pure java implementation of NDD (Network Decision Diagram), which supports efficient formal modeling for network verification tools (e.g., APVerifier, APT, APKeep, SRE and Batfish).

## Publication

**NDD: A Decision Diagram for Network Verification** (Proceedings of USENIX NSDI'25).

Author:
* Zechun Li - [mail](mailto:1467874668@qq.com) - XJTU
* Peng Zhang - [mail](mailto:p-zhang@xjtu.edu.cn) - XJTU professor
* Yichi Zhang - [mail](augists@outlook.com) - XJTU
* Hongkun Yang - [mail](hkyang@google.com) - Google

```bibtex
@inproceedings {NDD,
  author = {Zechun Li and Peng Zhang and Yichi Zhang and Hongkun Yang},
  title = {{NDD}: A Decision Diagram for Network Verification},
  booktitle = {22th USENIX Symposium on Networked Systems Design and Implementation (NSDI 25)},
  year = {2025},
  isbn = {},
  address = {},
  pages = {},
  url = {},
  publisher = {USENIX Association},
  month = apr
}
```

## Introduction

**Definition 1.** A **Network Decision Diagram (NDD)** is a rooted, directed acyclic graph with:

- two terminal nodes ***true*** and ***false***, with an out-degree of zero.

- a set of non-terminal nodes. Each node u is associated with a variable var(u) representing a field of one or multiple bits, and has a set of outgoing edges, denoted as edges(u). Each e $\in$ edges(u) points to a successor of u, denoted as next(e), and has a predicate over the variable var(u), denoted as label(e).

- $\forall u, \forall x, y \in edges(u)$ with $x \ne y$: $label(x)\wedge label(y) = false$, and $\bigvee_{e \in edges(u)}label(e) = true$.

**Todo: add a figure of redundancy in NDD.**

**Definition 2.** A NDD is said to be an **Ordered (ONDD)** if the field variables follow a fixed variable order
(say $f_1 < f_2 < ...,< f_n$ where $f_i < f_j$ means variable $f_i$ appears before variable $f_j$) on all paths through the graph. An ONDD is said to be a **Reduced (RONDD)** if it satisfies the following three conditions:
- Uniqueness: no two distinct nodes represent the same variable and have the same successors;
- No redundant node: no non-terminal node has only edge e with $label(e) = true$;
- No redundant edges: no two edges from the same node point to the same successor, i.e., $\forall u,\forall x, y \in edge(u) : next(x) = next(y) \Rightarrow x = y$.

**Todo:   部分符号使用花体**

**Atomized Network Decision Diagram** is an NDD where the label of each edge is a set of atoms, instead of a BDD. Before introducing the formal definition, we define some notations. Given a set of NDDs N , we use Df(N) to denote the set of  all descendants (direct or indirect successors) of some NDD with $n \in N$ and $var(n) = f$.

**Definition 3.** Given a set of NDDs N for a set of variables F, we say A(f) = {{a_1}^f,...,{a_k}^f} is the set of **atoms** for variable f ∈ F, with respect with N , if it satisfies the following conditions:
- $a_i^f \ne false,\forall i ∈ {1,..., k}$;
- $\vee_{i=1}^k a_i^f = true$;
- $a_i^f∧a_j^f = false$, if $i \ne j$;
- for $e \in edges(u), u \in D(N), var(u) = f$, there exists a set $atoms(e) \subset A(f)$, s.t., $label(e) = \bigvee_{a_i^f∈A(f)}a_i^f$;
- k is the minimum number satisfy the above properties.

**Definition 4.** Given a set of NDDs N, we say N a is the atomized NDDs of N , if $N^a = N$ , except that for each $e \in edges(u)$, where $u \in D(N^a), var(u) = f: label(e) \leftarrow atoms(e)$.

## Project structure

- `/doc` stores an api documentation generated by `javadoc`.
- `/lib` stores the third party jar packages.
	- `jdd-111.jar` is a modified version of [jdd library](https://bitbucket.org/vahidi/jdd), which source code can be [access](https://github.com/Augists/jdd).
	- `javabdd_1.0b2.tar.gz` is the original version of [javabdd](https://sourceforge.net/projects/javabdd/).
- `/results` stores some experimental results generated by codes in `/src/experiment`.
- `/src` stores source code.

## Installation

// Todo: add content.

## Getting Started

* `jndd`

An [example](/src/main/java/application/nqueen/NDDSolution.java) shows how to solve the NQueens problem by NDD.

```java
// init NDD library
NDD.initNDD(NDD_TABLE_SIZE, 1 + Math.max(1000, (int) (Math.pow(4.4, n - 6)) * 1000), 10000);

// declare ndd fields
for (int i = 0; i < n; i++) {
	NDD.declareField(n);
}

// constraints
NDD[] orBatch = new NDD[n];
NDD[][] impBatch = new NDD[n][n];

for (int i = 0; i < n; i++) {
	NDD condition = NDD.getFalse();
	for (int j = 0; j < n; j++) {
		condition = NDD.orTo(condition, NDD.getVar(i, j));
	}
	orBatch[i] = condition;
}

for (int i = 0; i < n; i++) {
	for (int j = 0; j < n; j++) {
		build(i, j, n, impBatch);
	}
}

// result computation
NDD queen = NDD.getTrue();

for (int i = 0; i < n; i++) {
	queen = NDD.andTo(queen, orBatch[i]);
	NDD.deref(orBatch[i]);
}
for (int i = 0; i < n; i++) {
	for (int j = 0; j < n; j++) {
		queen = NDD.andTo(queen, impBatch[i][j]);
		NDD.deref(impBatch[i][j]);
	}
}

return NDD.satCount(queen);
```

* `JavaNDD`

Library and its usage can be access in [src/main/java/org/ants/javandd](src/main/java/org/ants/javandd/README.md)
  
## API Examples
 
Todo: add examples.
  
- Encode common semantics
  
- Atomization in batch
  
- Incremental update
  
- Model packet transformers