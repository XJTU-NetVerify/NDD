# A library for Network Decision Diagram

This is a prototype implementation of the following [paper](https://xjtu-netverify.github.io/papers/NDD/NDD-final-version.pdf):

> Zechun Li, Peng Zhang, Yichi Zhang, and Hongkun Yang. "NDD: A Decision Diagram for Network Verification", NSDI 2025

## Introduction

**Network Decision Diagram (NDD)** is a new decision diagram customized for network verification. It is more efficient than BDD when used for network verification, in terms of memory and computation. NDD wraps BDD with another layers of decision diagram, such that each node represents a **field** of the network, and each edge is labeled with a BDD encoding the values of that field. Due to the **locality** of fields in networks, NDD can significantly reduce the redundant nodes. 

As an example, the figure below shows three BDDs in (a), and three equivalent NDDs in (c), each edge of which is labelled by per-field BDDs in (b).

![fig4 drawio](NDD.svg)

**Atomized Network Decision Diagram (Atomized NDD)** is an extension of NDD, which offers a native support for equivalence classes, a key technique underlying most network verifiers.
In atomized NDD, the label of each edge is a set of atoms, instead of a BDD as in standard NDD.
Using atomized NDD, network verifiers do not need to implement their own algorithms for computing and updating equivalence classes.

<!--
### Definitions

**Definition 1.** A **Network Decision Diagram (NDD)** is a rooted, directed acyclic graph with:

- two terminal nodes ***true*** and ***false***, with an out-degree of zero.

- a set of non-terminal nodes. Each node u is associated with a variable var(u) representing a field of one or multiple bits, and has a set of outgoing edges, denoted as edges(u). Each e $\in$ edges(u) points to a successor of u, denoted as next(e), and has a predicate over the variable var(u), denoted as label(e).

- $\forall u, \forall x, y \in edges(u)$ with $x \ne y$: $label(x)\wedge label(y) = false$, and $\bigvee_{e \in edges(u)}label(e) = true$.

**Todo: add a figure of redundancy in NDD.**

**Definition 2.** A NDD is said to be an **Ordered (ONDD)** if the field variables follow a fixed variable order
(say $f_1 < f_2 < ...,< f_n$ where $f_i < f_j$ means variable $f_i$ appears before variable $f_j$) on all paths through the graph. An ONDD is said to be a **Reduced (RONDD)** if it satisfies the following three conditions:
- Uniqueness: no two distinct nodes represent the same variable and have the same successors;
- No redundant node: no non-terminal node has only edge e with $label(e) = true$;
- No redundant edges: no two edges from the same node point to the same successor, i.e., $\forall u,\forall x, y \in edge(u) : next(x) = next(y) \Rightarrow x = y$.

**Definition 3.** Given a set of NDDs $N$ for a set of variables $F$, we say $A(f) = {{a_1}^f,...,{a_k}^f}$ is the set of **atoms** for variable $f \in F$, with respect with $N$ , if it satisfies the following conditions:
- $a_i^f \ne false,\forall i ∈ {1,..., k}$;
- $\vee_{i=1}^k a_i^f = true$;
- $a_i^f∧a_j^f = false$, if $i \ne j$;
- $\forall e \in edges(u)$, $u$ is a node of $N$ $var(u) = f$: there exists a set $atoms(e) \subset A(f)$, s.t., $label(e) = $\bigvee_{a \in atoms(e)}a$;
- $k$ is the minimum number satisfy the above properties.

**Definition 4.** Given a set of NDDs $N$, we say $N^a$ a is the **atomized NDDs** of $N$, if $N^a = N$ , except that for each $e$ of $N^a$: $label(e) \leftarrow atoms(e)$.
-->

## Project Structure

- `/doc` stores an api documentation generated by `javadoc`.
- `/lib` stores the third party jar packages.
    - `jdd-111.jar` is a modified version of [jdd library](https://bitbucket.org/vahidi/jdd). The jar has been decompiled into `/src/main/java/jdd` so it can be edited directly.
    - `javabdd_1.0b2.tar.gz` is the original version of [javabdd](https://sourceforge.net/projects/javabdd/) (for comparison).
- `/results` stores some experimental results generated by codes in `/src/experiment`.
- `/src` stores source code.

## Getting Started

* lib
    * `/lib/ndd-1.0-jar-with-dependencies.jar`
    * [`/lib/jdd-111.jar`](https://github.com/Augists/jdd/releases/tag/111-modified)
    
add `<dependency>` in `pom.xml`

```xml
<dependencies>
    <dependency>
        <groupId>org.ants</groupId>
        <artifactId>ndd</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/lib/ndd-1.0-jar-with-dependencies.jar</systemPath>
    </dependency>
</dependencies>
```

After Maven sync, `jndd` and `javandd` can be chosen to import by:

```java
import org.ants.jndd.*;
// or
import org.ants.javandd.*;
```

### JNDD

```java
/**
 * init NDD library
 * define cache size by `initNDD(NDD_TABLE_SIZE, NDD_CACHE_SIZE, BDD_TABLE_SIZE, BDD_CACHE_SIZE)` if required (default 10000)
 */
NDD.initNDD(NDD_TABLE_SIZE, BDD_TABLE_SIZE, BDD_CACHE_SIZE);

/**
 * declare ndd fields based on the situation {x, y, z}
 */
for (int i = 0; i < n; i++) {
    NDD.declareField(n);    // same number of variables in every field in nqueens
}

/**
 * ndd logical operation
 */
NDD[] orBatch = new NDD[n];
for (int i = 0; i < n; i++) {
    /**
     * `getTrue()` or `getFalse()` to get NDD terminal nodes
     */
    NDD condition = NDD.getFalse();
    for (int j = 0; j < n; j++) {
        /**
         * `getVar(field_num, num)` same as `ithVar` after `createVar` in BDD
         * `orTo` will free (`deref`) the NDD variable in the first parameter
         * use `or` instead to keep it
         */
        condition = NDD.orTo(condition, NDD.getVar(i, j));
    }
    orBatch[i] = condition;
}

NDD queen = NDD.getTrue();

/**
 * sat count for result
 */
NDD.satCount(queen);
```

### JavaNDD

> If you are using a BDD version of factory and changing to NDD, please refer to [`src/main/java/org/ants/javandd/README.md`](/src/main/java/org/ants/javandd/README.md)

```java
BDDFactory factory = new NDDFactory(BDD_TABLE_SIZE, BDD_CACHE_SIZE);

int[] fields = {}; // partion fields

factory.setVarNum(fields, NDD_TABLE_SIZE);

BDD TRUE = factory.one();
BDD FALSE = factory.zero();

BDD[] bdd_list = {};
for () {
    // or use `factory.getVar(field_num, num)` but it is incompatible with other factory
    // `ithVar(i)` will find its `field_num` first
    bdd_list[i] = factory.ithVar(i);
}

for (BDD bdd : bdd_list) {
    TRUE.and(bdd);
    FALSE.orWith(bdd);  // `applyWith` will free (`deref`) the BDD in parameter
}

return TRUE.satCount();
```

> It is our first time to get access to the APIs in `JavaBDD`. If some are misunderstood, please contact us or Pull Request if you can. Your contribution to **N**etwork **D**ecision **D**iagram is much appreciated.

## GC Log Output

NDD provides optional GC (Garbage Collection) log output for debugging and performance analysis. When enabled, detailed logs will be printed before and after GC operations for both JDD (BDD layer) and NDD layers.

### Enable GC Log

```java
import jdd.util.Options;

// Enable GC log output
Options.gc_log = true;

// Disable GC log output (default)
Options.gc_log = false;
```

### Log Output Format

When `Options.gc_log = true`, GC operations will output logs like:

```
[JDD GC] Start: table_size=10000, free_nodes=500, dead_nodes=100
[NDD GC] Start (triggered by JDD prehook): currentSize=5000, tableSize=100000
[NDD GC] End (triggered by JDD prehook): freed=200, currentSize=4800, time=15ms
[JDD GC] End: #5, freed=300, free_nodes=800, time=25ms
```

For JavaNDD (NDDFactory), the log prefix is `[JavaNDD GC]` instead of `[NDD GC]`.

The `triggered by` field indicates whether the NDD GC was:
- `JDD prehook`: Called automatically before JDD GC to ensure NDD nodes are cleaned up first
- `NDD self`: Triggered by NDD's own table size limit

## Benchmark

Benchmark (time `second`) on **NQueens**

| N | BDD (JDD) | BDD (JavaBDD - JFactory) | NDD (JNDD) |
| - | --------- | ------------- | -------------------- |
| 6 | 0.017 | 0.056 | 0.012 |
| 7 | 0.023 | 0.072 | 0.019 |
| 8 | 0.04  | 0.109 | 0.038 |
| 9 | 0.223 | 0.28 | 0.176 |
| 10 | 0.615 | 0.913 | 0.344 |
| 11 | 2.567 | 4.424 | 2.257 |
| 12 | 19.109 | 33.024 | 12.417 |

## Bibtex

```bibtex
@inproceedings {NDD,
  author = {Zechun Li, Peng Zhang, Yichi Zhang, Hongkun Yang},
  title = {{NDD}: A Decision Diagram for Network Verification},
  booktitle = {22th USENIX Symposium on Networked Systems Design and Implementation (NSDI 25)},
  year = {2025},
  isbn = {},
  address = {},
  pages = {},
  url = {https://www.usenix.org/conference/nsdi25/presentation},
  publisher = {USENIX Association},
  month = apr
}
```

### Contact

- Zechun Li (1467874668@qq.com)
- Peng Zhang (p-zhang@xjtu.edu.cn)
- Yichi Zhang (augists@outlook.com)
- Hongkun Yang (hkyang@google.com)

## License

Apache-2.0 License, see [LICENSE](LICENSE).
