# A library for Network Decision Diagram

This is a prototype implementation of the following [paper](https://xjtu-netverify.github.io/papers/NDD/NDD-final-version.pdf):

> Zechun Li, Peng Zhang, Yichi Zhang, and Hongkun Yang. "NDD: A Decision Diagram for Network Verification", NSDI 2025

## Introduction

**Network Decision Diagram (NDD)** is a new decision diagram customized for network verification. It is more efficient than BDD when used for network verification, in terms of memory and computation. NDD wraps BDD with another layers of decision diagram, such that each node represents a **field** of the network, and each edge is labeled with a BDD encoding the values of that field. Due to the **locality** of fields in networks, NDD can significantly reduce the redundant nodes. 

As an example, the figure below shows three BDDs in (a), and three equivalent NDDs in (c), each edge of which is labelled by per-field BDDs in (b).

![fig4 drawio](NDD.svg)

**Atomized Network Decision Diagram (Atomized NDD)** is an extension of NDD, which offers a native support for equivalence classes, a key technique underlying most network verifiers.
In atomized NDD, the label of each edge is a set of atoms, instead of a BDD as in standard NDD.
Using atomized NDD, network verifiers do not need to implement their own algorithms for computing and updating equivalence classes.

<!--
### Definitions

**Definition 1.** A **Network Decision Diagram (NDD)** is a rooted, directed acyclic graph with:

- two terminal nodes ***true*** and ***false***, with an out-degree of zero.

- a set of non-terminal nodes. Each node u is associated with a variable var(u) representing a field of one or multiple bits, and has a set of outgoing edges, denoted as edges(u). Each e $\in$ edges(u) points to a successor of u, denoted as next(e), and has a predicate over the variable var(u), denoted as label(e).

- $\forall u, \forall x, y \in edges(u)$ with $x \ne y$: $label(x)\wedge label(y) = false$, and $\bigvee_{e \in edges(u)}label(e) = true$.

**Todo: add a figure of redundancy in NDD.**

**Definition 2.** A NDD is said to be an **Ordered (ONDD)** if the field variables follow a fixed variable order
(say $f_1 < f_2 < ...,< f_n$ where $f_i < f_j$ means variable $f_i$ appears before variable $f_j$) on all paths through the graph. An ONDD is said to be a **Reduced (RONDD)** if it satisfies the following three conditions:
- Uniqueness: no two distinct nodes represent the same variable and have the same successors;
- No redundant node: no non-terminal node has only edge e with $label(e) = true$;
- No redundant edges: no two edges from the same node point to the same successor, i.e., $\forall u,\forall x, y \in edge(u) : next(x) = next(y) \Rightarrow x = y$.

**Definition 3.** Given a set of NDDs $N$ for a set of variables $F$, we say $A(f) = {{a_1}^f,...,{a_k}^f}$ is the set of **atoms** for variable $f \in F$, with respect with $N$ , if it satisfies the following conditions:
- $a_i^f \ne false,\forall i ∈ {1,..., k}$;
- $\vee_{i=1}^k a_i^f = true$;
- $a_i^f∧a_j^f = false$, if $i \ne j$;
- $\forall e \in edges(u)$, $u$ is a node of $N$ $var(u) = f$: there exists a set $atoms(e) \subset A(f)$, s.t., $label(e) = $\bigvee_{a \in atoms(e)}a$;
- $k$ is the minimum number satisfy the above properties.

**Definition 4.** Given a set of NDDs $N$, we say $N^a$ a is the **atomized NDDs** of $N$, if $N^a = N$ , except that for each $e$ of $N^a$: $label(e) \leftarrow atoms(e)$.
-->

## Project Structure

- `/doc` stores an api documentation generated by `javadoc`.
- `/lib` stores the third party jar packages.
    - `jdd-111.jar` is a modified version of [jdd library](https://bitbucket.org/vahidi/jdd), whose source code can be [access](https://github.com/Augists/jdd).
    - `javabdd_1.0b2.tar.gz` is the original version of [javabdd](https://sourceforge.net/projects/javabdd/) (for comparison).
- `/results` stores some experimental results generated by codes in `/src/experiment`.
- `/src` stores source code.

## Getting Started

* lib
    * `/lib/ndd-1.0-jar-with-dependencies.jar`
    * [`/lib/jdd-111.jar`](https://github.com/Augists/jdd/releases/tag/111-modified)
    
add `<dependency>` in `pom.xml`

```xml
<dependencies>
    <dependency>
        <groupId>org.ants</groupId>
        <artifactId>ndd</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/lib/ndd-1.0-jar-with-dependencies.jar</systemPath>
    </dependency>
    <dependency>
        <groupId>org.ants</groupId>
        <artifactId>jdd</artifactId>
        <version>111</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/lib/jdd-111.jar</systemPath>
    </dependency>
</dependencies>
```

After Maven sync, `jndd` and `javandd` can be chosen to import by:

```java
import org.ants.jndd.*;
// or
import org.ants.javandd.*;
```

### JNDD

```java
/**
 * init NDD library
 * define cache size by `initNDD(NDD_TABLE_SIZE, NDD_CACHE_SIZE, BDD_TABLE_SIZE, BDD_CACHE_SIZE)` if required (default 10000)
 */
NDD.initNDD(NDD_TABLE_SIZE, BDD_TABLE_SIZE, BDD_CACHE_SIZE);

/**
 * declare ndd fields based on the situation {x, y, z}
 */
for (int i = 0; i < n; i++) {
    NDD.declareField(n);    // same number of variables in every field in nqueens
}

/**
 * ndd logical operation
 */
NDD[] orBatch = new NDD[n];
for (int i = 0; i < n; i++) {
    /**
     * `getTrue()` or `getFalse()` to get NDD terminal nodes
     */
    NDD condition = NDD.getFalse();
    for (int j = 0; j < n; j++) {
        /**
         * `getVar(field_num, num)` same as `ithVar` after `createVar` in BDD
         * `orTo` will free (`deref`) the NDD variable in the first parameter
         * use `or` instead to keep it
         */
        condition = NDD.orTo(condition, NDD.getVar(i, j));
    }
    orBatch[i] = condition;
}

NDD queen = NDD.getTrue();

/**
 * sat count for result
 */
NDD.satCount(queen);
```

### JavaNDD

> If you are using a BDD version of factory and changing to NDD, please refer to [`src/main/java/org/ants/javandd/README.md`](/src/main/java/org/ants/javandd/README.md)

```java
BDDFactory factory = new NDDFactory(BDD_TABLE_SIZE, BDD_CACHE_SIZE);

int[] fields = {}; // partion fields

factory.setVarNum(fields, NDD_TABLE_SIZE);

BDD TRUE = factory.one();
BDD FALSE = factory.zero();

BDD[] bdd_list = {};
for () {
    // or use `factory.getVar(field_num, num)` but it is incompatible with other factory
    // `ithVar(i)` will find its `field_num` first
    bdd_list[i] = factory.ithVar(i);
}

for (BDD bdd : bdd_list) {
    TRUE.and(bdd);
    FALSE.orWith(bdd);  // `applyWith` will free (`deref`) the BDD in parameter
}

return TRUE.satCount();
```

> It is our first time to get access to the APIs in `JavaBDD`. If some are misunderstood, please contact us or Pull Request if you can. Your contribution to **N**etwork **D**ecision **D**iagram is much appreciated.

## Benchmark

Benchmark (time `second`) on **NQueens**

| N | BDD (JDD) | BDD (JavaBDD - JFactory) | NDD (JNDD) |
| - | --------- | ------------- | -------------------- |
| 6 | 0.017 | 0.056 | 0.012 |
| 7 | 0.023 | 0.072 | 0.019 |
| 8 | 0.04  | 0.109 | 0.038 |
| 9 | 0.223 | 0.28 | 0.176 |
| 10 | 0.615 | 0.913 | 0.344 |
| 11 | 2.567 | 4.424 | 2.257 |
| 12 | 19.109 | 33.024 | 12.417 |

## Bibtex

```bibtex
@inproceedings {NDD,
  author = {Zechun Li, Peng Zhang, Yichi Zhang, Hongkun Yang},
  title = {{NDD}: A Decision Diagram for Network Verification},
  booktitle = {22th USENIX Symposium on Networked Systems Design and Implementation (NSDI 25)},
  year = {2025},
  isbn = {},
  address = {},
  pages = {},
  url = {https://www.usenix.org/conference/nsdi25/presentation},
  publisher = {USENIX Association},
  month = apr
}
```

### Contact

- Zechun Li (1467874668@qq.com)
- Peng Zhang (p-zhang@xjtu.edu.cn)
- Yichi Zhang (augists@outlook.com)
- Hongkun Yang (hkyang@google.com)

## License

Apache-2.0 License, see [LICENSE](LICENSE).
